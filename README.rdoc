=DeceptiCon
Simplify and DRY your Rails controller specs by automating the simple response tests, leaving you free to test the important aspects.

Still a work in progress.  More changes and more docs to come.


==Does this apply to you?

* Your controllers have only seven deadly methods [:index, :show, :new, :create, :edit, :update, :destroy]
* Your routes are resourceful and the actions map to the expected CRUD actions - http://guides.rubyonrails.org/routing.html#crud-verbs-and-actions
* Your controller actions respond_to :html, :js, :xml or :json.  Some actions respond_to all formats, some respond to a few and some actions are completely blocked.
* Your controller tests are so similar you get double vision looking at them
* You want to simply test the basic <tt>should be_success</tt> or <tt>should_not be_success</tt> assertions for each action and each format (at least html and js).
  * but you're basically writing the same tests over and over for each controller and each action,
  * it takes at least 10 lines of controller_spec to test just one action with two formats, ie;

      describe "show"
        it 'should be available with HTML' do
          get, :show, {:id => @valid_object.id}
          response.should be_success
        end
        it 'should be unavailable with JS' do
          xhr :get, :show, {:id => @valid_object.id}
          response.should_not be_success
        end
      end
    Just testing the basic responses to html and js to each action is going to take at least 70 lines!

* You just want to focus on testing the interesting behaviors of your controllers and leave this repetitive stuff to a robot!
* Controller testing is so boring and repetitive it makes you cry.

==DRY your eyes
Here is a controller_spec which tests the html and js (ajax) responses to each of the seven actions and asserts if the response should be successful or not.

  require 'spec_helper'
  describe NotesController do
    before(:each) do
      #whatever....
    end

    @test_formats = [:html, :ajax] #by default :xml and :json would also be included
    @action_mapping = { #mapping of action-format to expectation
      :index => {:html => true,  :ajax => false}, #:ajax == :js
      :show =>  {:html => true,  :ajax => false},
      :new =>   {:html => false, :ajax => true},
      :create =>{:html => false, :ajax => true},
      :edit =>  {:html => false, :ajax => true},
      :update =>{:html => true,  :ajax => true},
      :destroy=>{:html => false, :ajax => false},
    }
    assert_mapping #generate tests which describe the above expectations.

    it 'should leave me free to now test the important details'
  end


===What's going on here then?
Two tests have been generated for each of the seven controller actions to test their response to both html and js requests.
Each of the 14 generated tests attempts to make the appropriate request and asserts if it should be_success or not.

Each of the tests for html, xml and json requests uses the appropriate test method (`get, put, post and delete`) and changes the format by setting <tt>@request.env['HTTP_ACCEPT']</tt>, ie;
  @request.env['HTTP_ACCEPT'] = "application/json" #for json request

Test for js requests use the `xhr` method which takes :get, :put, :post or :delete as its first arg.

For each of the actions it makes assumptions about what to include in the params of the request.
* In the case of :index and :new no params are supplied in the request. ie; <tt>params = {}</tt>
* For :create the params include attributes for the appropriate object. ie; <tt>params = {:note => {:text => "foo"}}</tt>
* For :update the params include attributes for the object and an :id.  ie; <tt>params = {:note => {:text => "bar"}, :id => 1}</tt>
* All other actions (:show, :edit, :destroy) just get an :id.           ie; <tt>params = {:id => 1}</tt>


====Important Prerequisite
For all the actions, aside from :index and :new, the test needs to construct a test object to be used in the controller.
If you have Factories set up it will use <tt>Factory.build(class_name)</tt>.
It also allows you to have <tt>valid_object</tt> methods ie; +valid_note+ or +valid_user_comment+ to return an object.
It will use a valid_object method in preference to a Factory if both are available.
The class of the object is derived from the controller name, but can be over-ridden (see settings).


It is the expectation that an object returned by either a Factory or a valid_object method will return true for <tt>.valid?</tt>
If it can't find a Factory or valid_object method it will attempt to create an object and populate its attributes (with string or ints) to try to make it valid but this only work for objects with very simple validations.

Once the request is made it calls either <tt>response.should be_success or response.should_not be_success</tt> depending on the value given for the particular action and format.
As well as just true and false you can also use :redirect ie;
  :edit => {:html => :redirect, :ajax => false}

At some point I will also add the ability to pass status codes in for more granular control.

The generation of the tests is done by the +assert_mapping+ method in the DeceptiCon module which needs to be required and included in the spec_helper.  See Setup later for complete instructions.

====example of generated tests
  it "should respond to index:html"
  it "should respond to new:ajax"
  it "should NOT respond to new:html"

====Be Lazy
You only need to define the mapping for actions which have the expectation of a successful response.  The others will be assumed to expect an unsuccessful response.

  @action_mapping = { :index => {:html => true} }

Without other options (see later), using the above action_mapping would result in all seven actions being tested for their response to each of the four formats (html, js, xml, json) but only the html response to index is expected to be successful.
By default all four formats (html, js, xml, json) are tested for all seven actions.
You can adjust this for all controllers or just for the current.  See more in Options later.

==Setup

First put the 'decepticon.rb' file into your spec dir. Then require and include it in your spec_helper.rb (or in specific controller_spec)
  require 'decepticon'
  include DeceptiCon

In your controller_spec you need to define the <tt>@action_mapping</tt> variable.  It should be defined inside a describe block, but *not* inside a +before+ or +all+ filter.


<tt>@action_mapping</tt> is a hash with a key for each action.  Each action entails another hash which defines the formats which the action will <tt>respond_to</tt> and the expectation of the request; <tt>{:action => {:format => expectation of request}}</tt>.
The expectation of the request is either +true+ or +false+ to denote if the <tt>response.should be_success</tt> or if the <tt>response.should_not be_success</tt>.
    @action_mapping = { :index => {:html => true,  :ajax => false}, :show =>  {:html => true,  :ajax => true}, ....}
Any action which is not included will be considered to not have successful responses to either format.

Add a call to a method from the DeceptiCon module after the <tt>@action_mapping</tt> definition

  assert_mapping

Finally (I know, this is a _lot_ of work) make sure you have a Factory ready for the given object class

  Factory.define(:note) { |f| f.text "some text" }

Now run your specs

==Options
By Default all seven actions will be tested for all four formats, you might not want this.

You can set which formats are tested for all controllers by adding a $default_test_formats array where you require and include DeceptiCon in the spec_helper.  Note, this var needs to be set before it is included.
  $default_test_formats = [:html, :ajax] #limit to just :html and :ajax formats
  require 'decepticon'
  include DeceptiCon

You can also control which formats to test on a per-controller basis by including a @test_formats array alongside the @action_mapping.
  @test_format = [:html, :xml]

This over-rides anything set by $default_test_formats

You can control which actions are tested on a per-controller basis.  By default all seven actions are tested but you can include an array (@skip_actions) to have some actions ignored.
  @skip_actions = [:edit, :update, :destroy] #these three will not be tested.

In the tests an object will be created.  The class of this object is derived from the name of the controller being tested.
ie; Note for NotesController.  This can be over-ridden by adding <tt>@object</tt> alongside <tt>@action_mapping</tt>, ie;
    @object = DifferentNote

==Extending the params
You can also pass in additional params to be added to the request, ie;

   @action_mapping = {
      :index => {:html => true,  :ajax => false, :html_args => {:limit => 5} },
      :show =>  {:html => true,  :ajax => false},
      :new =>   {:html => false, :ajax => true,  :ajax_args => {:published => false} },
      :create =>{:html => true,  :ajax => true,  :args => {:assign_to_user => "valid_user.id"}, :ajax_args => {:preview => true} },
      :edit =>  {:html => false, :ajax => true},
      :update =>{:html => true,  :ajax => true},
      :destroy=>{:html => false, :ajax => false},
    }

Additional params supplied with the key :args will be included in requests to all formats.
To include params for specific formats use the key :<format>_args, ie <tt>:html_args</tt>.

Note the args being passed to the create action; <tt>:args => {:user_id => "valid_user.id"}</tt>.
The <tt>valid_user.id</tt> is a string not a method or variable.  Before additional params are added any which are strings are eval'd.
This allows methods and variables to be called in the scope of the test (could not make work with Procs).  Its not ideal.

==Other Stuff
As well as the main +assert_mapping+ method the DeceptiCon class also provides another method called +fetch+.
This is used to unify the way you make requests to different formats.

For example to make html requests you write;
  get :index
  post :update, params

To make js requests you write;
  xhr :get, :index
  xhr :post, :update, params

To make either :xml or :json requests you add the line;
  @request.env['HTTP_ACCEPT'] = "application/#{format}"
where format is either "xml" or "json", and then use get, post, put or delete just like an html request.

So, thats a little vexatious when trying to use it programatically.

So now you can write
  fetch :html, :index
  fetch :ajax, :index
  fetch :json, :index
  fetch :html, :update, params
  fetch :ajax, :update, params
  fetch :json, :update, params

get, post etc can take four args
  get(:show, {'id' => "12"}, {'user_id' => 5}, {'message' => 'booya!'})

fetch passes the four args
  fetch(:html, :show, {'id' => "12"}, {'user_id' => 5}, {'message' => 'booya!'})



==Example Controller Spec
A controller spec which tests all seven actions, both html and js formats for three different types of User.

    require 'spec_helper'

    describe HelpDocumentsController do

      describe "Accessibility by non-logged-in users" do
        @object = HelpDocument
        @action_mapping = {  } #no mapping of actions => completely blocked, all actions are {:html => false, :ajax => false}
        assert_mapping
      end

      describe "Accessibility by logged-in users without roles" do
        before(:each) do
          assume_logged_in_user
        end
        @object = HelpDocument
        @action_mapping = {  } #no mapping of actions => completely blocked, all actions are {:html => false, :ajax => false}
        assert_mapping
      end

      describe "Accessibility by logged-in users with admin role" do
        before(:each) do
          assume_logged_in_user
          @current_user.add_role :admin
        end

        @object = HelpDocument
        @action_mapping = {
          :index => {:html => true,  :ajax => false},
          :show =>  {:html => false, :ajax => false},
          :new =>   {:html => false, :ajax => false},
          :create =>{:html => true,  :ajax => false},
          :edit =>  {:html => true,  :ajax => false},
          :update =>{:html => true,  :ajax => true},
          :destroy=>{:html => true,  :ajax => false}
        }
        assert_mapping
      end


    end
